<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ··ä¹±æ£‹å±€ - è±¡æ£‹Ã—å›´æ£‹Ã—ç‚¸å¼¹</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            chaos: {
              red: '#C8102E',
              black: '#1a1a1a',
              wood: '#D2691E',
              gold: '#FFD700',
              green: '#228B22',
              bomb: '#FF4500'
            }
          }
        }
      }
    }
  </script>

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', sans-serif;
    }

    canvas {
      cursor: pointer;
      touch-action: none;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .action-btn {
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .action-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .action-btn:active {
      transform: scale(0.95);
    }

    .action-btn.selected {
      box-shadow: 0 0 0 3px #FFD700;
      transform: scale(1.05);
    }

    @keyframes explosion {
      0% {
        transform: scale(0);
        opacity: 1;
      }

      50% {
        transform: scale(1.5);
        opacity: 0.8;
      }

      100% {
        transform: scale(2);
        opacity: 0;
      }
    }

    .explosion {
      animation: explosion 0.6s ease-out;
    }

    @keyframes shake {

      0%,
      100% {
        transform: translateX(0);
      }

      25% {
        transform: translateX(-5px);
      }

      75% {
        transform: translateX(5px);
      }
    }

    .shake {
      animation: shake 0.3s ease-in-out;
    }

    /* Game Modal */
    .game-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease-out;
    }

    .game-modal.show {
      display: flex;
    }

    .modal-content-box {
      background: white;
      border-radius: 24px;
      padding: 48px 40px;
      max-width: 500px;
      width: 90%;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      animation: slideUp 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .modal-icon {
      font-size: 80px;
      margin-bottom: 20px;
      animation: bounce 0.6s ease-out;
    }

    .modal-title {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 16px;
      color: #1a1a1a;
    }

    .modal-message {
      font-size: 18px;
      color: #666;
      margin-bottom: 32px;
      line-height: 1.6;
    }

    .modal-button {
      background: linear-gradient(135deg, #C8102E 0%, #8B0000 100%);
      color: white;
      border: none;
      padding: 16px 48px;
      border-radius: 12px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(200, 16, 46, 0.3);
    }

    .modal-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(200, 16, 46, 0.4);
    }

    .modal-button:active {
      transform: translateY(0);
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(50px) scale(0.9);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes bounce {

      0%,
      100% {
        transform: scale(1);
      }

      25% {
        transform: scale(1.1);
      }

      50% {
        transform: scale(0.95);
      }

      75% {
        transform: scale(1.05);
      }
    }
  </style>
</head>

<body class="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100">
  <main class="container mx-auto px-4 py-6 max-w-5xl">
    <!-- Header -->
    <header class="text-center mb-6">
      <h1 class="text-5xl font-bold text-chaos-red mb-2">ğŸ­ æ··ä¹±æ£‹å±€ ğŸ­</h1>
      <p class="text-lg text-gray-700">è±¡æ£‹ âš”ï¸ å›´æ£‹ âš« æ‰‘å…‹ç‚¸å¼¹ ğŸ’£</p>
    </header>

    <!-- Game Status -->
    <div class="bg-white rounded-2xl shadow-lg p-6 mb-6">
      <div class="flex justify-between items-center flex-wrap gap-4">
        <div>
          <div class="text-2xl font-bold" id="turn-status">ğŸ”´ çº¢æ–¹å›åˆ</div>
          <div class="text-sm text-gray-600 mt-1" id="action-hint">é€‰æ‹©æ“ä½œï¼šç§»åŠ¨è±¡æ£‹ / ä¸‹å›´æ£‹ / ä½¿ç”¨ç‚¸å¼¹</div>
        </div>
        <div class="flex gap-2">
          <button onclick="game.undo()" class="action-btn px-4 py-2 bg-gray-500 text-white rounded-lg font-semibold">
            â†¶ æ‚”æ£‹
          </button>
          <button onclick="game.restart()"
            class="action-btn px-4 py-2 bg-chaos-red text-white rounded-lg font-semibold">
            ğŸ”„ é‡æ–°å¼€å§‹
          </button>
        </div>
      </div>
    </div>

    <!-- Action Mode Selector -->
    <div class="bg-white rounded-2xl shadow-lg p-6 mb-6">
      <h3 class="font-bold text-lg mb-4">é€‰æ‹©æ“ä½œæ¨¡å¼ï¼š</h3>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <button onclick="game.setMode('chess')" id="mode-chess"
          class="action-btn selected px-6 py-4 bg-chaos-red text-white rounded-xl font-bold text-lg">
          â™Ÿï¸ ç§»åŠ¨è±¡æ£‹
        </button>
        <button onclick="game.setMode('go')" id="mode-go"
          class="action-btn px-6 py-4 bg-gray-300 text-gray-700 rounded-xl font-bold text-lg">
          âš« ä¸‹å›´æ£‹
        </button>
        <button onclick="game.setMode('bomb')" id="mode-bomb"
          class="action-btn px-6 py-4 bg-gray-300 text-gray-700 rounded-xl font-bold text-lg">
          ğŸ’£ ç‚¸å¼¹ (<span id="bomb-count-red">2</span>/<span id="bomb-count-black">2</span>)
        </button>
      </div>
    </div>

    <!-- Canvas -->
    <div class="flex justify-center mb-6">
      <canvas id="game-canvas" class="rounded-xl bg-chaos-wood"></canvas>
    </div>

    <!-- Instructions -->
    <div class="bg-white rounded-2xl shadow-lg p-6">
      <h3 class="font-bold text-lg mb-3">ğŸ“– æ¸¸æˆè§„åˆ™</h3>
      <div class="space-y-2 text-gray-700">
        <p><strong>ğŸ¯ èƒœåˆ©æ¡ä»¶ï¼š</strong>å°†æ­»å¯¹æ–¹ï¼Œæˆ–å¯¹æ–¹å°†/å¸…è¢«åƒæ‰/ææ‰/ç‚¸æ‰</p>
        <p><strong>â™Ÿï¸ è±¡æ£‹æ¨¡å¼ï¼šï¼š</strong>æ­£å¸¸è±¡æ£‹è§„åˆ™ï¼Œç‚¹å‡»æ£‹å­é€‰ä¸­ï¼Œç‚¹å‡»ç›®æ ‡ä½ç½®ç§»åŠ¨ï¼Œ<span class="text-red-600">å¯ä»¥åƒæ‰å›´æ£‹å­</span></p>
        <p><strong>âš« å›´æ£‹æ¨¡å¼ï¼š</strong>åœ¨äº¤å‰ç‚¹ä¸‹å›´æ£‹å­ï¼Œ<span class="text-red-600">éµå¾ªå›´æ£‹æå­è§„åˆ™ï¼ˆæ— æ°”è¢«æï¼‰</span>ï¼Œå››é¢åŒ…å›´å¯ææ‰è±¡æ£‹å­</p>
        <p><strong>ğŸ² æ°”çš„å®šä¹‰ï¼š</strong>æ£‹å­å‘¨å›´çš„<span class="text-red-600">ç©ºä½</span>å°±æ˜¯æ°”ï¼ŒåŒè‰²ç›¸è¿çš„æ£‹å­å…±äº«æ°”ï¼Œæ²¡æœ‰æ°”æ—¶è¢«ææ‰</p>
        <p><strong>ğŸ”— è¿é€šå…±æ°”ï¼š</strong>åŒè‰²ç›¸é‚»çš„å›´æ£‹å­æˆ–è±¡æ£‹å­<span class="text-red-600">å½¢æˆè¿é€šå—å…±äº«æ°”</span>ï¼Œè¿åœ¨ä¸€èµ·æ›´éš¾è¢«åŒ…å›´</p>
        <p><strong>ğŸ”§ å›´æ£‹æˆ˜æœ¯ï¼š</strong>å›´æ£‹å­å¯ä½œä¸º<span class="text-red-600">ç‚®æ¶ã€è¹©é©¬è…¿ã€æŒ¡è½¦</span>ç­‰ï¼Œå‚ä¸è±¡æ£‹æˆ˜æ–—</p>
        <p><strong>ğŸ’£ ç‚¸å¼¹æ¨¡å¼ï¼š</strong>æ¯æ–¹2æ¬¡æœºä¼šï¼Œç‚¹å‡»ä¸­å¿ƒç‚¹ç‚¸æ‰3Ã—3åŒºåŸŸå†…æ‰€æœ‰æ£‹å­ï¼ˆè±¡æ£‹+å›´æ£‹ï¼‰ï¼Œå°†/å¸…å…ç–«</p>
        <p><strong>ğŸ”„ å›åˆæœºåˆ¶ï¼š</strong>æ¯å›åˆåªèƒ½é€‰æ‹©ä¸€ç§æ“ä½œï¼ˆç§»åŠ¨è±¡æ£‹ OR ä¸‹å›´æ£‹ OR ä½¿ç”¨ç‚¸å¼¹ï¼‰</p>
      </div>
    </div>
  </main>

  <!-- Kill Feed Container -->
  <div id="kill-feed" class="fixed top-4 right-4 flex flex-col gap-2 pointer-events-none z-50"></div>

  <!-- Check Alert -->
  <div id="check-alert" class="fixed top-1/3 left-1/2 transform -translate-x-1/2 hidden z-[100] pointer-events-none">
    <div
      class="bg-red-600 text-white px-10 py-4 rounded-full shadow-2xl text-5xl font-bold border-4 border-yellow-400 tracking-widest animate-alert-shake"
      style="background-color: rgba(220, 38, 38, 0.9);">
      âš ï¸ å°† å†›ï¼
    </div>
  </div>

  <!-- Game Modal -->
  <div id="game-modal" class="game-modal">
    <div class="modal-content-box">
      <div id="modal-icon" class="modal-icon">ğŸ‰</div>
      <div id="modal-title" class="modal-title">æ¸¸æˆç»“æŸ</div>
      <div id="modal-message" class="modal-message">æ¶ˆæ¯å†…å®¹</div>
      <button id="modal-close-btn" class="modal-button">ç¡®å®š</button>
    </div>
  </div>

  <style>
    /* Kill Feed Animations */
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    .kill-feed-item {
      animation: slideInRight 0.3s ease-out forwards;
    }

    .kill-feed-item.fading {
      animation: fadeOut 0.5s ease-in forwards;
    }

    @keyframes alert-shake {

      0%,
      100% {
        transform: translateX(-50%);
      }

      10%,
      30%,
      50%,
      70%,
      90% {
        transform: translateX(calc(-50% - 10px));
      }

      20%,
      40%,
      60%,
      80% {
        transform: translateX(calc(-50% + 10px));
      }
    }

    .animate-alert-shake {
      animation: alert-shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
    }

    /* Custom scrollbar for rules */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #CBD5E0;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #A0AEC0;
    }
  </style>

  <script>
    class ChaosChessGame {
      constructor() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');

        // Board settings
        this.gridSize = 50;
        this.padding = 40;
        this.boardWidth = 8;  // è±¡æ£‹9æ¡çº¿ = 8æ ¼
        this.boardHeight = 9; // è±¡æ£‹10æ¡çº¿ = 9æ ¼

        this.canvas.width = this.gridSize * this.boardWidth + this.padding * 2;
        this.canvas.height = this.gridSize * this.boardHeight + this.padding * 2;

        // Game state
        this.currentPlayer = 'red'; // red or black
        this.mode = 'chess'; // chess, go, bomb
        this.selectedPiece = null;
        this.history = [];
        this.gameOver = false; // æ¸¸æˆæ˜¯å¦ç»“æŸ

        // Bombs remaining
        this.bombs = { red: 2, black: 2 };

        // Initialize board
        this.initBoard();
        this.draw();

        // Event listeners
        this.canvas.addEventListener('click', (e) => this.handleClick(e));
      }

      initBoard() {
        // Chess pieces (è±¡æ£‹)
        this.chessPieces = [
          // Red pieces (bottom)
          { type: 'è½¦', x: 0, y: 9, player: 'red' },
          { type: 'é©¬', x: 1, y: 9, player: 'red' },
          { type: 'ç›¸', x: 2, y: 9, player: 'red' },
          { type: 'ä»•', x: 3, y: 9, player: 'red' },
          { type: 'å¸…', x: 4, y: 9, player: 'red' },
          { type: 'ä»•', x: 5, y: 9, player: 'red' },
          { type: 'ç›¸', x: 6, y: 9, player: 'red' },
          { type: 'é©¬', x: 7, y: 9, player: 'red' },
          { type: 'è½¦', x: 8, y: 9, player: 'red' },
          { type: 'ç‚®', x: 1, y: 7, player: 'red' },
          { type: 'ç‚®', x: 7, y: 7, player: 'red' },
          { type: 'å…µ', x: 0, y: 6, player: 'red' },
          { type: 'å…µ', x: 2, y: 6, player: 'red' },
          { type: 'å…µ', x: 4, y: 6, player: 'red' },
          { type: 'å…µ', x: 6, y: 6, player: 'red' },
          { type: 'å…µ', x: 8, y: 6, player: 'red' },

          // Black pieces (top)
          { type: 'è½¦', x: 0, y: 0, player: 'black' },
          { type: 'é©¬', x: 1, y: 0, player: 'black' },
          { type: 'è±¡', x: 2, y: 0, player: 'black' },
          { type: 'å£«', x: 3, y: 0, player: 'black' },
          { type: 'å°†', x: 4, y: 0, player: 'black' },
          { type: 'å£«', x: 5, y: 0, player: 'black' },
          { type: 'è±¡', x: 6, y: 0, player: 'black' },
          { type: 'é©¬', x: 7, y: 0, player: 'black' },
          { type: 'è½¦', x: 8, y: 0, player: 'black' },
          { type: 'ç‚®', x: 1, y: 2, player: 'black' },
          { type: 'ç‚®', x: 7, y: 2, player: 'black' },
          { type: 'å’', x: 0, y: 3, player: 'black' },
          { type: 'å’', x: 2, y: 3, player: 'black' },
          { type: 'å’', x: 4, y: 3, player: 'black' },
          { type: 'å’', x: 6, y: 3, player: 'black' },
          { type: 'å’', x: 8, y: 3, player: 'black' },
        ];

        // Go stones (å›´æ£‹)
        this.goStones = [];
      }

      setMode(mode) {
        this.mode = mode;
        this.selectedPiece = null;

        // Update button styles
        ['chess', 'go', 'bomb'].forEach(m => {
          const btn = document.getElementById(`mode-${m}`);
          if (m === mode) {
            btn.classList.add('selected');
            btn.classList.remove('bg-gray-300', 'text-gray-700');
            btn.classList.add(m === 'chess' ? 'bg-chaos-red' : m === 'go' ? 'bg-chaos-black' : 'bg-chaos-bomb', 'text-white');
          } else {
            btn.classList.remove('selected', 'bg-chaos-red', 'bg-chaos-black', 'bg-chaos-bomb', 'text-white');
            btn.classList.add('bg-gray-300', 'text-gray-700');
          }
        });

        this.updateHint();
        this.draw();
      }

      handleClick(e) {
        // æ¸¸æˆç»“æŸåç¦æ­¢æ“ä½œ
        if (this.gameOver) return;

        const rect = this.canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        // Convert to grid coordinates
        const gridX = Math.round((clickX - this.padding) / this.gridSize);
        const gridY = Math.round((clickY - this.padding) / this.gridSize);

        if (gridX < 0 || gridX > 8 || gridY < 0 || gridY > 9) return;

        if (this.mode === 'chess') {
          this.handleChessClick(gridX, gridY);
        } else if (this.mode === 'go') {
          this.handleGoClick(gridX, gridY);
        } else if (this.mode === 'bomb') {
          this.handleBombClick(gridX, gridY);
        }
      }

      handleChessClick(x, y) {
        const piece = this.getPieceAt(x, y);

        if (this.selectedPiece) {
          // Try to move
          if (this.isValidMove(this.selectedPiece, x, y)) {
            this.saveHistory();

            // Capture enemy piece
            const target = this.getPieceAt(x, y);
            if (target) {
              const killerIcon = this.selectedPiece.player === 'red' ? 'ğŸ”´' : 'âš«';
              const victimIcon = target.player === 'red' ? 'ğŸ”´' : 'âš«';
              this.showKillFeed(`${killerIcon} ${this.selectedPiece.type}`, `${victimIcon} ${target.type}`, 'eat');

              this.chessPieces = this.chessPieces.filter(p => p !== target);
            }

            // Capture go stone at target position (è±¡æ£‹å¯ä»¥åƒæ‰å›´æ£‹å­)
            const targetGoStone = this.getGoStoneAt(x, y);
            if (targetGoStone) {
              const killerIcon = this.selectedPiece.player === 'red' ? 'ğŸ”´' : 'âš«';
              const victimIcon = targetGoStone.player === 'red' ? 'ğŸ”´' : 'âš«';
              this.showKillFeed(`${killerIcon} ${this.selectedPiece.type}`, `${victimIcon} å›´æ£‹`, 'eat');

              this.goStones = this.goStones.filter(s => s !== targetGoStone);
            }

            // Move piece
            this.selectedPiece.x = x;
            this.selectedPiece.y = y;
            this.selectedPiece = null;

            // å…ˆæ£€æŸ¥èƒœè´Ÿï¼ˆåƒå­å¯¼è‡´çš„ï¼‰
            if (this.checkWinCondition()) {
              this.draw();
              return;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰æ£‹å­è¢«å›´æ£‹åŒ…å›´ææ‰
            this.checkCapturedPieces();

            // å†æ¬¡æ£€æŸ¥èƒœè´Ÿï¼ˆæå­å¯¼è‡´çš„ï¼‰
            if (this.checkWinCondition()) {
              this.draw();
              return;
            }

            this.nextTurn();
          } else {
            this.selectedPiece = null;
          }
        } else if (piece && piece.player === this.currentPlayer) {
          this.selectedPiece = piece;
        }

        this.draw();
      }

      nextTurn() {
        this.currentPlayer = this.currentPlayer === 'red' ? 'black' : 'red';
        this.updateStatus();
        this.updateHint();
        this.updateBombCount();

        // æ£€æŸ¥å°†å†›çŠ¶æ€
        this.checkForCheck();
      }

      checkForCheck() {
        const checkAlert = document.getElementById('check-alert');
        if (this.isCheck(this.currentPlayer)) {
          checkAlert.classList.remove('hidden');

          // é‡ç½®åŠ¨ç”»
          const innerDiv = checkAlert.firstElementChild;
          innerDiv.style.animation = 'none';
          innerDiv.offsetHeight; /* trigger reflow */
          innerDiv.style.animation = '';

          // 2ç§’åè‡ªåŠ¨æ¶ˆå¤±
          if (this.checkTimeout) clearTimeout(this.checkTimeout);
          this.checkTimeout = setTimeout(() => {
            checkAlert.classList.add('hidden');
          }, 2000);
        } else {
          checkAlert.classList.add('hidden');
        }
      }

      // æ£€æŸ¥æŸæ–¹æ˜¯å¦è¢«å°†å†›
      isCheck(player) {
        const general = this.findGeneral(player);
        if (!general) return false;

        // 1. æ£€æŸ¥å›´æ£‹å¨èƒï¼ˆå°†/å¸…æ‰€åœ¨è¿é€šå—åªå‰©ä¸€å£æ°”ï¼‰
        const liberties = this.countChessPieceLiberties(general);
        if (liberties === 1) {
          console.log(`[Check] ${player} general low on liberties!`);
          return true;
        }

        // 2. æ£€æŸ¥è±¡æ£‹å¨èƒ
        const enemyPlayer = player === 'red' ? 'black' : 'red';
        // éå†æ‰€æœ‰æ•Œæ–¹æ£‹å­
        return this.chessPieces.some(piece => {
          if (piece.player === enemyPlayer) {
            const canAttack = this.isValidMove(piece, general.x, general.y);
            if (canAttack) {
              console.log(`[Check] ${piece.type} at (${piece.x},${piece.y}) checks General at (${general.x},${general.y})`);
            }
            return canAttack;
          }
          return false;
        });
      }

      findGeneral(player) {
        return this.chessPieces.find(p => p.player === player && (p.type === 'å°†' || p.type === 'å¸…'));
      }

      // æ˜¾ç¤ºå‡»æ€æç¤º (CS:GO é£æ ¼)
      showKillFeed(killerName, victimName, type = 'eat') {
        const feedContainer = document.getElementById('kill-feed');
        const item = document.createElement('div');
        item.className = 'kill-feed-item flex items-center bg-black/60 border border-gray-500 text-white px-3 py-1 rounded text-sm font-bold shadow-md';

        const killerColor = killerName.includes('ğŸ”´') || killerName.includes('çº¢') ? 'text-red-400' : 'text-gray-300';
        const victimColor = victimName.includes('ğŸ”´') || victimName.includes('çº¢') ? 'text-red-400' : 'text-gray-300';
        const icon = type === 'capture' ? 'â˜ ï¸' : 'âš”ï¸';

        item.innerHTML = `
          <span class="${killerColor}">${killerName}</span>
          <span class="mx-2 text-yellow-400 text-lg">${icon}</span>
          <span class="${victimColor}">${victimName}</span>
        `;

        feedContainer.appendChild(item);

        // è‡ªåŠ¨ç§»é™¤
        setTimeout(() => {
          item.classList.add('fading');
          item.addEventListener('animationend', () => item.remove());
        }, 3000);
      }

      handleGoClick(x, y) {
        // Check if position is occupied
        if (this.getPieceAt(x, y) || this.getGoStoneAt(x, y)) {
          return;
        }

        this.saveHistory();

        // Place Go stone
        this.goStones.push({ x, y, player: this.currentPlayer });

        // Check if any enemy pieces are captured
        this.checkCapturedPieces();

        // æ£€æŸ¥èƒœè´Ÿï¼ˆæå­å¯¼è‡´çš„ï¼‰
        if (this.checkWinCondition()) {
          this.draw();
          return;
        }

        this.nextTurn();
        this.draw();
      }

      handleBombClick(x, y) {
        if (this.bombs[this.currentPlayer] <= 0) {
          this.showMessage('æ‚¨çš„ç‚¸å¼¹å·²ç»ç”¨å®Œäº†', 'ğŸ’£', 'ç‚¸å¼¹å·²ç”¨å®Œ');
          return;
        }

        this.saveHistory();

        // Explosion effect
        this.canvas.classList.add('shake');
        setTimeout(() => this.canvas.classList.remove('shake'), 300);

        // Remove pieces in 3x3 area
        const toRemove = [];
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const tx = x + dx;
            const ty = y + dy;

            // Remove chess pieces (except å°†/å¸…)
            const piece = this.getPieceAt(tx, ty);
            if (piece && piece.type !== 'å°†' && piece.type !== 'å¸…') {
              toRemove.push(piece);
            }

            // Remove go stones
            const stone = this.getGoStoneAt(tx, ty);
            if (stone) {
              toRemove.push(stone);
            }
          }
        }

        this.chessPieces = this.chessPieces.filter(p => !toRemove.includes(p));
        this.goStones = this.goStones.filter(s => !toRemove.includes(s));

        this.bombs[this.currentPlayer]--;
        this.updateBombCount();

        // æ£€æŸ¥èƒœè´Ÿï¼ˆç‚¸å¼¹å¯¼è‡´çš„ï¼‰
        if (this.checkWinCondition()) {
          this.draw();
          return;
        }

        this.nextTurn();
        this.draw();
      }

      isValidMove(piece, toX, toY, debug = false) {
        // Basic validation
        if (toX < 0 || toX > 8 || toY < 0 || toY > 9) return false;

        const target = this.getPieceAt(toX, toY);
        // Important: When checking for check, target IS the general (enemy), so this shouldn't return false.
        // But preventing friendly fire is correct.
        if (target && target.player === piece.player) return false;

        const dx = toX - piece.x;
        const dy = toY - piece.y;

        // Simplified movement rules
        switch (piece.type) {
          case 'è½¦': {
            const isStraight = (dx === 0 || dy === 0);
            const clear = this.isPathClear(piece.x, piece.y, toX, toY);
            if (debug && isStraight && !clear) console.log(`[CheckDebug] Rook path blocked from (${piece.x},${piece.y}) to (${toX},${toY})`);
            return isStraight && clear;
          }

          case 'é©¬':
            if (!((Math.abs(dx) === 2 && Math.abs(dy) === 1) || (Math.abs(dx) === 1 && Math.abs(dy) === 2))) {
              return false;
            }
            // æ£€æŸ¥é©¬è…¿ï¼ˆå›´æ£‹å­ä¹Ÿå¯ä»¥è¹©é©¬è…¿ï¼‰
            const legX = piece.x + (Math.abs(dx) === 2 ? Math.sign(dx) : 0);
            const legY = piece.y + (Math.abs(dy) === 2 ? Math.sign(dy) : 0);
            const legObstructed = this.getPieceAt(legX, legY) || this.getGoStoneAt(legX, legY);
            if (debug && legObstructed) console.log(`[CheckDebug] Knight blocked at leg (${legX},${legY})`);
            return !legObstructed;

          case 'ç‚®': {
            if (dx !== 0 && dy !== 0) return false;
            // æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦æœ‰æ£‹å­ï¼ˆè±¡æ£‹æˆ–å›´æ£‹ï¼‰
            const hasTargetPiece = target || this.getGoStoneAt(toX, toY);
            if (!hasTargetPiece) {
              // ç©ºç‚®ç§»åŠ¨ï¼Œè·¯å¾„å¿…é¡»æ¸…ç©º
              return this.isPathClear(piece.x, piece.y, toX, toY);
            } else {
              // æ‰“ç‚®åƒå­ï¼Œä¸­é—´å¿…é¡»æœ‰æ°å¥½ä¸€ä¸ªæ£‹å­ä½œä¸ºç‚®æ¶
              const screenCount = this.countPiecesBetween(piece.x, piece.y, toX, toY);
              if (debug && screenCount !== 1) console.log(`[CheckDebug] Cannon needs 1 screen, found ${screenCount}`);
              return screenCount === 1;
            }
          }

          case 'å…µ':
          case 'å’':
            const forward = piece.player === 'red' ? -1 : 1;
            const crossedRiver = piece.player === 'red' ? piece.y < 5 : piece.y > 4;
            if (dy === forward && dx === 0) return true;
            if (crossedRiver && dy === 0 && Math.abs(dx) === 1) return true;
            return false;

          case 'å°†':
          case 'å¸…':
            if (Math.abs(dx) + Math.abs(dy) !== 1) return false;
            const inPalace = toX >= 3 && toX <= 5 &&
              ((piece.player === 'red' && toY >= 7) ||
                (piece.player === 'black' && toY <= 2));
            return inPalace;

          case 'å£«':
          case 'ä»•':
            if (Math.abs(dx) !== 1 || Math.abs(dy) !== 1) return false;
            const inPalace2 = toX >= 3 && toX <= 5 &&
              ((piece.player === 'red' && toY >= 7) ||
                (piece.player === 'black' && toY <= 2));
            return inPalace2;

          case 'è±¡':
          case 'ç›¸':
            if (Math.abs(dx) !== 2 || Math.abs(dy) !== 2) return false;
            const ownSide = piece.player === 'red' ? toY >= 5 : toY <= 4;
            const eyeX = piece.x + dx / 2;
            const eyeY = piece.y + dy / 2;
            return ownSide && !this.getPieceAt(eyeX, eyeY);

          default:
            return false;
        }
      }

      checkCapturedPieces() {
        const toRemove = [];

        // å›´æ£‹è§„åˆ™ï¼šå…ˆææ‰æ•Œæ–¹æ²¡æœ‰æ°”çš„æ£‹å­ï¼Œå†æ£€æŸ¥å·±æ–¹æ˜¯å¦è‡ªæ€
        const currentPlayer = this.currentPlayer;
        const enemyPlayer = currentPlayer === 'red' ? 'black' : 'red';

        // 1. å…ˆæ£€æŸ¥å¹¶ææ‰æ•Œæ–¹å›´æ£‹å­ï¼ˆæ²¡æœ‰æ°”çš„ï¼‰
        this.goStones.forEach(stone => {
          if (stone.player === enemyPlayer) {
            const liberties = this.countLiberties(stone);
            if (liberties === 0) {
              toRemove.push(stone);
            }
          }
        });

        // 2. å…ˆæ£€æŸ¥å¹¶ææ‰æ•Œæ–¹è±¡æ£‹å­ï¼ˆæ²¡æœ‰æ°”çš„ï¼‰
        this.chessPieces.forEach(piece => {
          if (piece.player === enemyPlayer) {
            const liberties = this.countChessPieceLiberties(piece);
            if (liberties === 0) {
              toRemove.push(piece);
            }
          }
        });

        // å…ˆç§»é™¤æ•Œæ–¹æ£‹å­
        if (toRemove.length > 0) {
          this.goStones = this.goStones.filter(s => !toRemove.includes(s));
          this.chessPieces = this.chessPieces.filter(p => !toRemove.includes(p));
        }

        // 3. å†æ£€æŸ¥å·±æ–¹å›´æ£‹å­æ˜¯å¦è‡ªæ€ï¼ˆä¸‹å®Œå­åå·±æ–¹æ²¡æœ‰æ°”ï¼‰
        const friendlyToRemove = [];
        this.goStones.forEach(stone => {
          if (stone.player === currentPlayer) {
            const liberties = this.countLiberties(stone);
            if (liberties === 0) {
              friendlyToRemove.push(stone);
            }
          }
        });

        // 4. å†æ£€æŸ¥å·±æ–¹è±¡æ£‹å­æ˜¯å¦è¢«ææ‰
        this.chessPieces.forEach(piece => {
          if (piece.player === currentPlayer) {
            const liberties = this.countChessPieceLiberties(piece);
            if (liberties === 0) {
              friendlyToRemove.push(piece);
            }
          }
        });

        // ç§»é™¤å·±æ–¹æ£‹å­
        if (friendlyToRemove.length > 0) {
          this.goStones = this.goStones.filter(s => !friendlyToRemove.includes(s));
          this.chessPieces = this.chessPieces.filter(p => !friendlyToRemove.includes(p));
          toRemove.push(...friendlyToRemove);
        }

        // æ˜¾ç¤ºå‡»æ€æç¤º
        if (toRemove.length > 0) {
          const removedGoStones = toRemove.filter(item => item.x !== undefined && item.y !== undefined && !item.type);
          const removedChessPieces = toRemove.filter(item => item.type !== undefined);

          // èšåˆæ˜¾ç¤ºï¼šå›´æ£‹æå­
          if (removedGoStones.length > 0) {
            const victim = removedGoStones[0].player === 'red' ? 'ğŸ”´' : 'âš«';
            const killer = this.currentPlayer === 'red' ? 'ğŸ”´ å›´æ£‹' : 'âš« å›´æ£‹';
            this.showKillFeed(killer, `${victim} å›´æ£‹ (x${removedGoStones.length})`, 'capture');
          }

          // èšåˆæ˜¾ç¤ºï¼šè±¡æ£‹è¢«æ
          removedChessPieces.forEach(piece => {
            const victimIcon = piece.player === 'red' ? 'ğŸ”´' : 'âš«';
            const killer = this.currentPlayer === 'red' ? 'ğŸ”´ å›´æ£‹' : 'âš« å›´æ£‹';
            this.showKillFeed(killer, `${victimIcon} ${piece.type}`, 'capture');
          });
        }
      }


      // è®¡ç®—å›´æ£‹å­çš„æ°”ï¼ˆè‡ªç”±åº¦ï¼‰
      countLiberties(stone) {
        const visited = new Set();
        const group = this.getConnectedGroup(stone, visited);
        const liberties = new Set();

        // æ£€æŸ¥æ•´ä¸ªè¿é€šå—çš„æ‰€æœ‰æ°”
        group.forEach(s => {
          const positions = [
            { x: s.x - 1, y: s.y },
            { x: s.x + 1, y: s.y },
            { x: s.x, y: s.y - 1 },
            { x: s.x, y: s.y + 1 }
          ];

          positions.forEach(pos => {
            // åœ¨æ£‹ç›˜èŒƒå›´å†…
            if (pos.x >= 0 && pos.x <= 8 && pos.y >= 0 && pos.y <= 9) {
              // åªæœ‰ç©ºä½ç®—æ°”ï¼Œä»»ä½•æ£‹å­ï¼ˆå›´æ£‹æˆ–è±¡æ£‹ï¼‰éƒ½ä¸ç®—æ°”
              const goStone = this.getGoStoneAt(pos.x, pos.y);
              const chessPiece = this.getPieceAt(pos.x, pos.y);

              if (!goStone && !chessPiece) {
                liberties.add(`${pos.x},${pos.y}`);
              }
            }
          });
        });

        return liberties.size;
      }
      // è·å–è¿é€šçš„å›´æ£‹å­ç»„ï¼ˆåŒè‰²ç›¸è¿çš„æ£‹å­ï¼ŒåŒ…æ‹¬è±¡æ£‹å­ï¼‰
      getConnectedGroup(stone, visited = new Set()) {
        const key = `go_${stone.x},${stone.y}`;
        if (visited.has(key)) return [];

        visited.add(key);
        const group = [stone];

        const positions = [
          { x: stone.x - 1, y: stone.y },
          { x: stone.x + 1, y: stone.y },
          { x: stone.x, y: stone.y - 1 },
          { x: stone.x, y: stone.y + 1 }
        ];

        positions.forEach(pos => {
          // 1. æ£€æŸ¥åŒè‰²å›´æ£‹å­
          const adjacentStone = this.getGoStoneAt(pos.x, pos.y);
          if (adjacentStone && adjacentStone.player === stone.player) {
            const connectedGroup = this.getConnectedGroup(adjacentStone, visited);
            group.push(...connectedGroup);
          }

          // 2. æ£€æŸ¥åŒè‰²è±¡æ£‹å­ (äº’ç›¸é€’å½’)
          const adjacentPiece = this.getPieceAt(pos.x, pos.y);
          if (adjacentPiece && adjacentPiece.player === stone.player) {
            const connectedGroup = this.getConnectedChessPieces(adjacentPiece, visited);
            group.push(...connectedGroup);
          }
        });

        return group;
      }

      // è®¡ç®—è±¡æ£‹å­çš„æ°”ï¼ˆè‡ªç”±åº¦ï¼‰- åŒè‰²ç›¸è¿çš„è±¡æ£‹å­å…±äº«æ°”
      countChessPieceLiberties(piece) {
        const visited = new Set();
        const group = this.getConnectedChessPieces(piece, visited);
        const liberties = new Set();

        // æ£€æŸ¥æ•´ä¸ªè¿é€šå—çš„æ‰€æœ‰æ°”
        group.forEach(p => {
          const positions = [
            { x: p.x - 1, y: p.y },
            { x: p.x + 1, y: p.y },
            { x: p.x, y: p.y - 1 },
            { x: p.x, y: p.y + 1 }
          ];

          positions.forEach(pos => {
            // åœ¨æ£‹ç›˜èŒƒå›´å†…
            if (pos.x >= 0 && pos.x <= 8 && pos.y >= 0 && pos.y <= 9) {
              // åªæœ‰ç©ºä½ç®—æ°”ï¼Œä»»ä½•æ£‹å­ï¼ˆå›´æ£‹æˆ–è±¡æ£‹ï¼‰éƒ½ä¸ç®—æ°”
              const goStone = this.getGoStoneAt(pos.x, pos.y);
              const chessPiece = this.getPieceAt(pos.x, pos.y);

              if (!goStone && !chessPiece) {
                liberties.add(`${pos.x},${pos.y}`);
              }
            }
          });
        });

        return liberties.size;
      }

      // è·å–è¿é€šçš„è±¡æ£‹å­ç»„ï¼ˆåŒè‰²ç›¸è¿çš„æ£‹å­ï¼ŒåŒ…æ‹¬å›´æ£‹å­ï¼‰
      getConnectedChessPieces(piece, visited = new Set()) {
        const key = `piece_${piece.x},${piece.y}`;
        if (visited.has(key)) return [];

        visited.add(key);
        const group = [piece];

        const positions = [
          { x: piece.x - 1, y: piece.y },
          { x: piece.x + 1, y: piece.y },
          { x: piece.x, y: piece.y - 1 },
          { x: piece.x, y: piece.y + 1 }
        ];

        positions.forEach(pos => {
          // 1. æ£€æŸ¥åŒè‰²è±¡æ£‹å­
          const adjacentPiece = this.getPieceAt(pos.x, pos.y);
          if (adjacentPiece && adjacentPiece.player === piece.player) {
            const connectedGroup = this.getConnectedChessPieces(adjacentPiece, visited);
            group.push(...connectedGroup);
          }

          // 2. æ£€æŸ¥åŒè‰²å›´æ£‹å­ (äº’ç›¸é€’å½’)
          const adjacentStone = this.getGoStoneAt(pos.x, pos.y);
          if (adjacentStone && adjacentStone.player === piece.player) {
            const connectedGroup = this.getConnectedGroup(adjacentStone, visited);
            group.push(...connectedGroup);
          }
        });

        return group;
      }

      isPathClear(x1, y1, x2, y2) {
        const dx = Math.sign(x2 - x1);
        const dy = Math.sign(y2 - y1);
        let x = x1 + dx;
        let y = y1 + dy;

        while (x !== x2 || y !== y2) {
          // å›´æ£‹å­å’Œè±¡æ£‹å­éƒ½ä¼šé˜»æŒ¡è·¯å¾„
          if (this.getPieceAt(x, y) || this.getGoStoneAt(x, y)) return false;
          x += dx;
          y += dy;
        }
        return true;
      }

      countPiecesBetween(x1, y1, x2, y2) {
        const dx = Math.sign(x2 - x1);
        const dy = Math.sign(y2 - y1);
        let x = x1 + dx;
        let y = y1 + dy;
        let count = 0;

        while (x !== x2 || y !== y2) {
          // å›´æ£‹å­å’Œè±¡æ£‹å­éƒ½å¯ä½œä¸ºç‚®æ¶
          if (this.getPieceAt(x, y) || this.getGoStoneAt(x, y)) count++;
          x += dx;
          y += dy;
        }
        return count;
      }

      getPieceAt(x, y) {
        return this.chessPieces.find(p => p.x === x && p.y === y);
      }

      getGoStoneAt(x, y) {
        return this.goStones.find(s => s.x === x && s.y === y);
      }



      checkWinCondition() {
        const redGeneral = this.chessPieces.find(p => p.type === 'å¸…');
        const blackGeneral = this.chessPieces.find(p => p.type === 'å°†');

        if (!redGeneral) {
          this.gameOver = true;
          this.showMessage('çº¢å¸…è¢«æ¶ˆç­äº†ï¼\nç‚¹å‡»"é‡æ–°å¼€å§‹"ç»§ç»­æ¸¸æˆ', 'âš«', 'é»‘æ–¹è·èƒœï¼');
          return true;
        } else if (!blackGeneral) {
          this.gameOver = true;
          this.showMessage('é»‘å°†è¢«æ¶ˆç­äº†ï¼\nç‚¹å‡»"é‡æ–°å¼€å§‹"ç»§ç»­æ¸¸æˆ', 'ğŸ”´', 'çº¢æ–¹è·èƒœï¼');
          return true;
        }
        return false;
      }

      saveHistory() {
        this.history.push({
          chessPieces: JSON.parse(JSON.stringify(this.chessPieces)),
          goStones: JSON.parse(JSON.stringify(this.goStones)),
          bombs: { ...this.bombs },
          currentPlayer: this.currentPlayer
        });
      }

      undo() {
        if (this.history.length === 0) {
          this.showMessage('æ²¡æœ‰å¯ä»¥æ‚”æ£‹çš„æ­¥éª¤', 'âš ï¸', 'æ— æ³•æ‚”æ£‹');
          return;
        }

        const state = this.history.pop();
        this.chessPieces = state.chessPieces;
        this.goStones = state.goStones;
        this.bombs = state.bombs;
        this.currentPlayer = state.currentPlayer;
        this.selectedPiece = null;

        this.updateBombCount();
        this.updateStatus();
        this.draw();
      }

      restart() {
        this.history = [];
        this.currentPlayer = 'red';
        this.mode = 'chess';
        this.selectedPiece = null;
        this.bombs = { red: 2, black: 2 };
        this.gameOver = false; // é‡ç½®æ¸¸æˆçŠ¶æ€
        this.initBoard();
        this.setMode('chess');
        this.updateBombCount();
        this.updateStatus();
        this.checkForCheck(); // Ensure check status is updated on restart
        this.draw();
      }

      updateStatus() {
        const emoji = this.currentPlayer === 'red' ? 'ğŸ”´' : 'âš«';
        const name = this.currentPlayer === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
        document.getElementById('turn-status').textContent = `${emoji} ${name}å›åˆ`;
      }

      updateHint() {
        const hints = {
          chess: 'ç‚¹å‡»å·±æ–¹æ£‹å­é€‰ä¸­ï¼Œå†ç‚¹å‡»ç›®æ ‡ä½ç½®ç§»åŠ¨ï¼ˆå¯åƒæ‰å›´æ£‹å­ï¼‰',
          go: 'ç‚¹å‡»äº¤å‰ç‚¹ä¸‹å›´æ£‹ï¼Œå››é¢åŒ…å›´å¯ææ‰è±¡æ£‹å­ï¼Œå¯ä½œç‚®æ¶/è¹©é©¬è…¿/æŒ¡è½¦',
          bomb: 'ç‚¹å‡»ä¸­å¿ƒç‚¹ï¼Œç‚¸æ‰3Ã—3åŒºåŸŸå†…æ‰€æœ‰æ£‹å­ï¼ˆå°†/å¸…å…ç–«ï¼‰'
        };
        document.getElementById('action-hint').textContent = hints[this.mode];
      }

      updateBombCount() {
        document.getElementById('bomb-count-red').textContent = this.bombs.red;
        document.getElementById('bomb-count-black').textContent = this.bombs.black;
      }

      showMessage(msg, icon = 'ğŸ‰', title = 'æç¤º') {
        const modal = document.getElementById('game-modal');
        const modalIcon = document.getElementById('modal-icon');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');

        modalIcon.textContent = icon;
        modalTitle.textContent = title;
        modalMessage.textContent = msg;
        modal.classList.add('show');
      }

      draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw board
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;

        // Vertical lines
        for (let i = 0; i <= 8; i++) {
          const x = this.padding + i * this.gridSize;
          ctx.beginPath();
          ctx.moveTo(x, this.padding);
          ctx.lineTo(x, this.padding + this.boardHeight * this.gridSize);
          ctx.stroke();
        }

        // Horizontal lines
        for (let i = 0; i <= 9; i++) {
          const y = this.padding + i * this.gridSize;
          ctx.beginPath();
          ctx.moveTo(this.padding, y);
          ctx.lineTo(this.padding + this.boardWidth * this.gridSize, y);
          ctx.stroke();
        }

        // River
        ctx.fillStyle = '#666';
        ctx.font = '14px serif';
        ctx.textAlign = 'center';
        ctx.fillText('æ¥šæ²³', this.padding + this.gridSize * 2, this.padding + this.gridSize * 4.5 + 5);
        ctx.fillText('æ±‰ç•Œ', this.padding + this.gridSize * 6, this.padding + this.gridSize * 4.5 + 5);

        // Draw Go stones
        this.goStones.forEach(stone => {
          const x = this.padding + stone.x * this.gridSize;
          const y = this.padding + stone.y * this.gridSize;

          ctx.beginPath();
          ctx.arc(x, y, 12, 0, Math.PI * 2);

          if (stone.player === 'red') {
            // çº¢æ–¹å›´æ£‹ï¼šç™½è‰²å¸¦çº¢è¾¹
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.strokeStyle = '#C8102E';
            ctx.lineWidth = 3;
            ctx.stroke();
          } else {
            // é»‘æ–¹å›´æ£‹ï¼šé»‘è‰²
            ctx.fillStyle = '#1a1a1a';
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        });

        // Draw chess pieces
        this.chessPieces.forEach(piece => {
          const x = this.padding + piece.x * this.gridSize;
          const y = this.padding + piece.y * this.gridSize;

          // Check if surrounded (in danger) by enemy go stones
          const positions = [
            { x: piece.x - 1, y: piece.y },
            { x: piece.x + 1, y: piece.y },
            { x: piece.x, y: piece.y - 1 },
            { x: piece.x, y: piece.y + 1 }
          ];
          let enemySurroundCount = 0;
          positions.forEach(pos => {
            const stone = this.getGoStoneAt(pos.x, pos.y);
            // åªè®¡ç®—æ•Œæ–¹å›´æ£‹å­
            if (stone && stone.player !== piece.player) {
              enemySurroundCount++;
            }
          });
          const isSurrounded = enemySurroundCount >= 4;
          const isInDanger = enemySurroundCount === 3;

          // Circle background
          ctx.beginPath();
          ctx.arc(x, y, 20, 0, Math.PI * 2);
          ctx.fillStyle = piece.player === 'red' ? '#FFE4E1' : '#F0F0F0';
          ctx.fill();
          ctx.strokeStyle = piece.player === 'red' ? '#C8102E' : '#1a1a1a';
          ctx.lineWidth = isSurrounded ? 4 : 2;
          ctx.stroke();

          // Text
          ctx.fillStyle = piece.player === 'red' ? '#C8102E' : '#1a1a1a';
          ctx.font = 'bold 18px serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(piece.type, x, y);

          // Danger indicator (3 sides surrounded)
          if (isInDanger) {
            ctx.fillStyle = 'rgba(255, 165, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.fill();
          }

          // Surrounded indicator (about to be captured)
          if (isSurrounded) {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.fill();
          }

          // Selected highlight
          if (this.selectedPiece === piece) {
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 25, 0, Math.PI * 2);
            ctx.stroke();
          }
        });

        // Draw bomb preview in bomb mode
        if (this.mode === 'bomb') {
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = '#FF4500';
          // Will show on hover in real implementation
          ctx.globalAlpha = 1;
        }
      }
    }

    // Initialize game
    let game;
    window.addEventListener('DOMContentLoaded', () => {
      game = new ChaosChessGame();

      // Modal close handlers
      const modal = document.getElementById('game-modal');
      const modalCloseBtn = document.getElementById('modal-close-btn');

      modalCloseBtn.addEventListener('click', () => {
        modal.classList.remove('show');
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.remove('show');
        }
      });
    });
  </script>
</body>

</html>